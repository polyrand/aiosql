{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"aiosql - Simple SQL in Python \u00b6 SQL is code. Write it, version control it, comment it, and run it using files. Writing your SQL code in Python programs as strings doesn't allow you to easily reuse them in SQL GUIs or CLI tools like psql. With aiosql you can organize your SQL statements in .sql files, load them into your python application as methods to call without losing the ability to use them as you would any other SQL file. This project supports standard and asyncio based drivers for SQLite and PostgreSQL out of the box ( sqlite3 , aiosqlite , psycopg2 , asyncpg ). Extensions to support other database drivers can be written by you! See: Database Driver Adapters Danger This project supports asyncio based drivers and requires python versions >3.6. Installation \u00b6 pip install aiosql Or if you you use poetry : poetry add aiosql Usage \u00b6 greetings.sql -- name: get_all_greetings -- Get all the greetings in the database select greeting_id, greeting from greetings; -- name: get_user_by_username^ -- Get a user from the database select user_id, username, name from users where username = :username; example.py import asyncio import aiosql import aiosqlite queries = aiosql.from_path(\"./greetings.sql\", \"aiosqlite\") async def main(): # Parallel queries!!! async with aiosqlite.connect(\"greetings.db\") as conn: greetings, user = await asyncio.gather( queries.get_all_greetings(conn), queries.get_user_by_username(conn, username=\"willvaughn\") ) # greetings = [(1, \"Hi\"), (2, \"Aloha\"), (3, \"Hola\")] # user = (1, \"willvaughn\", \"William\") for _, greeting in greetings: print(f\"{greeting}, {user[2]}!\") # Hi, William! # Aloha, William! # Hola, William! asyncio.run(main()) This example has an imaginary SQLite database with greetings and users. It prints greetings in various languages to the user and showcases the basic feature of being able to load queries from a sql file and call them by name in python code. It also happens to do two SQL queries in parallel using aiosqlite and asyncio.","title":"Home"},{"location":"#aiosql-simple-sql-in-python","text":"SQL is code. Write it, version control it, comment it, and run it using files. Writing your SQL code in Python programs as strings doesn't allow you to easily reuse them in SQL GUIs or CLI tools like psql. With aiosql you can organize your SQL statements in .sql files, load them into your python application as methods to call without losing the ability to use them as you would any other SQL file. This project supports standard and asyncio based drivers for SQLite and PostgreSQL out of the box ( sqlite3 , aiosqlite , psycopg2 , asyncpg ). Extensions to support other database drivers can be written by you! See: Database Driver Adapters Danger This project supports asyncio based drivers and requires python versions >3.6.","title":"aiosql - Simple SQL in Python"},{"location":"#installation","text":"pip install aiosql Or if you you use poetry : poetry add aiosql","title":"Installation"},{"location":"#usage","text":"greetings.sql -- name: get_all_greetings -- Get all the greetings in the database select greeting_id, greeting from greetings; -- name: get_user_by_username^ -- Get a user from the database select user_id, username, name from users where username = :username; example.py import asyncio import aiosql import aiosqlite queries = aiosql.from_path(\"./greetings.sql\", \"aiosqlite\") async def main(): # Parallel queries!!! async with aiosqlite.connect(\"greetings.db\") as conn: greetings, user = await asyncio.gather( queries.get_all_greetings(conn), queries.get_user_by_username(conn, username=\"willvaughn\") ) # greetings = [(1, \"Hi\"), (2, \"Aloha\"), (3, \"Hola\")] # user = (1, \"willvaughn\", \"William\") for _, greeting in greetings: print(f\"{greeting}, {user[2]}!\") # Hi, William! # Aloha, William! # Hola, William! asyncio.run(main()) This example has an imaginary SQLite database with greetings and users. It prints greetings in various languages to the user and showcases the basic feature of being able to load queries from a sql file and call them by name in python code. It also happens to do two SQL queries in parallel using aiosqlite and asyncio.","title":"Usage"},{"location":"advanced-topics/","text":"Advanced Topics \u00b6 Leveraging Driver Specific Features \u00b6 Todo Access the cursor object \u00b6 Todo Accessing prepared SQL as a string \u00b6 When you need to do something not directly supported by aiosql, this is your escape hatch. You can still define your sql in a file and load it with aiosql, but then you may choose to use it without calling your aiosql method. The prepared SQL string of a method is available as an attribute of each method queries.<method_name>.sql . Here's an example of how you might use it with a unique feature of psycopg2 like execute_values . This example adapts the example usage from psycopg2's documentation for execute_values . >>> import aiosql >>> import psycopg2 >>> from psycopg2.extras import execute_values >>> sql_str = \"\"\" ... -- name: create_schema# ... create table test (id int primary key, v1 int, v2 int); ... ... -- name: insert! ... INSERT INTO test (id, v1, v2) VALUES %s; ... ... -- name: update! ... UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1) ... WHERE test.id = data.id; ... ... -- name: getem ... select * from test order by id; ... \"\"\" >>> >>> queries = aiosql.from_str(sql_str, \"psycopg2\") >>> conn = psycopg2.connect(\"dbname=test user=postgres\") >>> queries.create_schema(conn) >>> >>> cur = conn.cursor() >>> execute_values(cur, queries.insert.sql, [(1, 2, 3), (4, 5, 6), (7, 8, 9)]) >>> execute_values(cur, queries.update.sql, [(1, 20), (4, 50)]) >>> >>> queries.getem(conn) [(1, 20, 3), (4, 50, 6), (7, 8, 9)]) Sync & Async \u00b6 Below are two example of a program which can print \"{greeting}, {world_name}!\" from data held in a minimal SQLite database containing greetings and worlds. They use this same sql. greetings.sql -- name: get-all-greetings -- Get all the greetings in the database select greeting_id, greeting from greetings; -- name: get-worlds-by-name^ -- Get the world record from the database. select world_id, world_name from worlds where world_name = :world_name; Notice there is a usage of the ^ Select One Query Operator . Adding this to the SQL comment --name: get-world-by-name^ indicates to aiosql that queries.get_world_by_name() will return a single row back. Sync with sqlite3 \u00b6 Here we've set up our sqlite3 connection. Using the sqlite3.Row type for our records to make it easy to access values by column names rather than as tuple indices. The program works, it does two queries sqequentially then loops over their results to print greetings. import sqlite3 import aiosql queries = aiosql.from_path(\"greetings.sql\", driver_adapter=\"sqlite3\") conn = sqlite3.connect(\"greetings.db\") conn.row_factory = sqlite3.Row # greetings = [ # <Row greeting_id=1, greeting=\"Hi\">, # <Row greeting_id=2, greeting=\"Aloha\">, # <Row greeting_id=3, greeting=\"Hola\"> # ] greetings = queries.get_greetings(conn) # world = <Row world_id=1, world_name=\"Earth\"> world = queries.get_worlds_by_name(conn, world_name=\"Earth\") # Hi, Earth! # Aloha, Earth! # Hola, Earth! for greeting_row in greetings: print(f\"{greeting_row['greeting']}, {world['world_name']}!\") conn.close() Asyncio with aiosqlite \u00b6 This program is only a little bit different. It let's us leverage asyncio.gather to make both queries for greetings and worlds in parallel! import asyncio import aiosql import aiosqlite queries = aiosql.from_path(\"greetings.sql\", driver_adapter=\"aiosqlite\") async def main(): with async aiosqlite.connect(\"greetings.db\") as conn: conn.row_factory = aiosqlite.Row # Parallel queries!!! # # greetings = [ # <Row greeting_id=1, greeting=\"Hi\">, # <Row greeting_id=2, greeting=\"Aloha\">, # <Row greeting_id=3, greeting=\"Hola\"> # ] # world = <Row world_id=1, world_name=\"Earth\"> greeting_rows, world = await asyncio.gather( queries.get_all_greetings(conn), queries.get_world_by_name(conn, world_name=\"Earth\") ) # Hi, Earth! # Aloha, Earth! # Hola, Earth! for greeting_row in greeting_rows: print(f\"{greeting_row['greeting']}, {world['world_name']}!\") asyncio.run(main()) Slightly different usage with aiosqlite but I hope this has demonstrated in a small way the big power and performance possibilities with asyncronous queries using the async driver types. Type Hinting Queries with Protocols \u00b6 Todo","title":"Advanced Topics"},{"location":"advanced-topics/#advanced-topics","text":"","title":"Advanced Topics"},{"location":"advanced-topics/#leveraging-driver-specific-features","text":"Todo","title":"Leveraging Driver Specific Features"},{"location":"advanced-topics/#access-the-cursor-object","text":"Todo","title":"Access the cursor object"},{"location":"advanced-topics/#accessing-prepared-sql-as-a-string","text":"When you need to do something not directly supported by aiosql, this is your escape hatch. You can still define your sql in a file and load it with aiosql, but then you may choose to use it without calling your aiosql method. The prepared SQL string of a method is available as an attribute of each method queries.<method_name>.sql . Here's an example of how you might use it with a unique feature of psycopg2 like execute_values . This example adapts the example usage from psycopg2's documentation for execute_values . >>> import aiosql >>> import psycopg2 >>> from psycopg2.extras import execute_values >>> sql_str = \"\"\" ... -- name: create_schema# ... create table test (id int primary key, v1 int, v2 int); ... ... -- name: insert! ... INSERT INTO test (id, v1, v2) VALUES %s; ... ... -- name: update! ... UPDATE test SET v1 = data.v1 FROM (VALUES %s) AS data (id, v1) ... WHERE test.id = data.id; ... ... -- name: getem ... select * from test order by id; ... \"\"\" >>> >>> queries = aiosql.from_str(sql_str, \"psycopg2\") >>> conn = psycopg2.connect(\"dbname=test user=postgres\") >>> queries.create_schema(conn) >>> >>> cur = conn.cursor() >>> execute_values(cur, queries.insert.sql, [(1, 2, 3), (4, 5, 6), (7, 8, 9)]) >>> execute_values(cur, queries.update.sql, [(1, 20), (4, 50)]) >>> >>> queries.getem(conn) [(1, 20, 3), (4, 50, 6), (7, 8, 9)])","title":"Accessing prepared SQL as a string"},{"location":"advanced-topics/#sync-async","text":"Below are two example of a program which can print \"{greeting}, {world_name}!\" from data held in a minimal SQLite database containing greetings and worlds. They use this same sql. greetings.sql -- name: get-all-greetings -- Get all the greetings in the database select greeting_id, greeting from greetings; -- name: get-worlds-by-name^ -- Get the world record from the database. select world_id, world_name from worlds where world_name = :world_name; Notice there is a usage of the ^ Select One Query Operator . Adding this to the SQL comment --name: get-world-by-name^ indicates to aiosql that queries.get_world_by_name() will return a single row back.","title":"Sync &amp; Async"},{"location":"advanced-topics/#sync-with-sqlite3","text":"Here we've set up our sqlite3 connection. Using the sqlite3.Row type for our records to make it easy to access values by column names rather than as tuple indices. The program works, it does two queries sqequentially then loops over their results to print greetings. import sqlite3 import aiosql queries = aiosql.from_path(\"greetings.sql\", driver_adapter=\"sqlite3\") conn = sqlite3.connect(\"greetings.db\") conn.row_factory = sqlite3.Row # greetings = [ # <Row greeting_id=1, greeting=\"Hi\">, # <Row greeting_id=2, greeting=\"Aloha\">, # <Row greeting_id=3, greeting=\"Hola\"> # ] greetings = queries.get_greetings(conn) # world = <Row world_id=1, world_name=\"Earth\"> world = queries.get_worlds_by_name(conn, world_name=\"Earth\") # Hi, Earth! # Aloha, Earth! # Hola, Earth! for greeting_row in greetings: print(f\"{greeting_row['greeting']}, {world['world_name']}!\") conn.close()","title":"Sync with sqlite3"},{"location":"advanced-topics/#asyncio-with-aiosqlite","text":"This program is only a little bit different. It let's us leverage asyncio.gather to make both queries for greetings and worlds in parallel! import asyncio import aiosql import aiosqlite queries = aiosql.from_path(\"greetings.sql\", driver_adapter=\"aiosqlite\") async def main(): with async aiosqlite.connect(\"greetings.db\") as conn: conn.row_factory = aiosqlite.Row # Parallel queries!!! # # greetings = [ # <Row greeting_id=1, greeting=\"Hi\">, # <Row greeting_id=2, greeting=\"Aloha\">, # <Row greeting_id=3, greeting=\"Hola\"> # ] # world = <Row world_id=1, world_name=\"Earth\"> greeting_rows, world = await asyncio.gather( queries.get_all_greetings(conn), queries.get_world_by_name(conn, world_name=\"Earth\") ) # Hi, Earth! # Aloha, Earth! # Hola, Earth! for greeting_row in greeting_rows: print(f\"{greeting_row['greeting']}, {world['world_name']}!\") asyncio.run(main()) Slightly different usage with aiosqlite but I hope this has demonstrated in a small way the big power and performance possibilities with asyncronous queries using the async driver types.","title":"Asyncio with aiosqlite"},{"location":"advanced-topics/#type-hinting-queries-with-protocols","text":"Todo","title":"Type Hinting Queries with Protocols"},{"location":"api/","text":"API \u00b6 aiosql.from_path \u00b6 aiosql. from_path ( sql_path , driver_adapter , record_classes=None , * , loader_cls= , queries_cls= ) Load queries from a .sql file, or directory of .sql files. Parameters: sql_path - Path to a .sql file or directory containing .sql files. driver_adapter - Either a string to designate one of the aiosql built-in database driver adapters. One of \"sqlite3\", \"psycopg2\", \"aiosqlite\", or \"asyncpg\". If you have defined your own adapter class, you may pass its constructor. record_classes - (optional) DEPRECATED Mapping of strings used in \"record_class\" declarations to the python classes which aiosql should use when marshaling SQL results. loader_cls - (optional) Custom constructor for QueryLoader extensions. queries_cls - (optional) Custom constructor for Queries extensions. Returns: Queries Usage: >>> queries = aiosql.from_path(\"./sql\", \"pscycopg2\") >>> queries = aiosql.from_path(\"./sql\", MyDBAdapter) aiosql.from_str \u00b6 aiosql. from_str ( sql , driver_adapter , record_classes=None , * , loader_cls= , queries_cls= ) Load queries from a SQL string. Parameters: sql - A string containing SQL statements and aiosql name. driver_adapter - Either a string to designate one of the aiosql built-in database driver adapters. One of \"sqlite3\", \"psycopg2\", \"aiosqlite\", or \"asyncpg\". If you have defined your own adapter class, you can pass it's constructor. record_classes - (optional) DEPRECATED Mapping of strings used in \"record_class\" declarations to the python classes which aiosql should use when marshaling SQL results. loader_cls - (optional) Custom constructor for QueryLoader extensions. queries_cls - (optional) Custom constructor for Queries extensions. Returns: Queries Usage: Loading queries from a SQL string. import sqlite3 import aiosql sql_text = \"\"\" -- name: get-all-greetings -- Get all the greetings in the database select * from greetings; -- name: get-user-by-username^ -- Get all the users from the database, -- and return it as a dict select * from users where username = :username; \"\"\" queries = aiosql.from_str(sql_text, \"sqlite3\") queries.get_all_greetings(conn) queries.get_user_by_username(conn, username=\"willvaughn\")","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#aiosqlfrom_path","text":"aiosql. from_path ( sql_path , driver_adapter , record_classes=None , * , loader_cls= , queries_cls= ) Load queries from a .sql file, or directory of .sql files. Parameters: sql_path - Path to a .sql file or directory containing .sql files. driver_adapter - Either a string to designate one of the aiosql built-in database driver adapters. One of \"sqlite3\", \"psycopg2\", \"aiosqlite\", or \"asyncpg\". If you have defined your own adapter class, you may pass its constructor. record_classes - (optional) DEPRECATED Mapping of strings used in \"record_class\" declarations to the python classes which aiosql should use when marshaling SQL results. loader_cls - (optional) Custom constructor for QueryLoader extensions. queries_cls - (optional) Custom constructor for Queries extensions. Returns: Queries Usage: >>> queries = aiosql.from_path(\"./sql\", \"pscycopg2\") >>> queries = aiosql.from_path(\"./sql\", MyDBAdapter)","title":"aiosql.from_path"},{"location":"api/#aiosqlfrom_str","text":"aiosql. from_str ( sql , driver_adapter , record_classes=None , * , loader_cls= , queries_cls= ) Load queries from a SQL string. Parameters: sql - A string containing SQL statements and aiosql name. driver_adapter - Either a string to designate one of the aiosql built-in database driver adapters. One of \"sqlite3\", \"psycopg2\", \"aiosqlite\", or \"asyncpg\". If you have defined your own adapter class, you can pass it's constructor. record_classes - (optional) DEPRECATED Mapping of strings used in \"record_class\" declarations to the python classes which aiosql should use when marshaling SQL results. loader_cls - (optional) Custom constructor for QueryLoader extensions. queries_cls - (optional) Custom constructor for Queries extensions. Returns: Queries Usage: Loading queries from a SQL string. import sqlite3 import aiosql sql_text = \"\"\" -- name: get-all-greetings -- Get all the greetings in the database select * from greetings; -- name: get-user-by-username^ -- Get all the users from the database, -- and return it as a dict select * from users where username = :username; \"\"\" queries = aiosql.from_str(sql_text, \"sqlite3\") queries.get_all_greetings(conn) queries.get_user_by_username(conn, username=\"willvaughn\")","title":"aiosql.from_str"},{"location":"database-driver-adapters/","text":"Database Driver Adapters \u00b6 Database driver adapters in aiosql allow extension of the library to support additional database drivers. If you are using a driver other than the ones currently supported by built-in driver adapters ( sqlite3 , aiosqlite , psycopg2 , asyncpg ) then you will need to make your own. A database driver adapter is a duck-typed class that follows either of the Protocol types below. These types are defined in aiosql/types.py . Sync Adapter class SyncDriverAdapterProtocol(Protocol): def process_sql(self, query_name: str, op_type: SQLOperationType, sql: str) -> str: ... def select( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> List: ... def select_one( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> Optional[Any]: ... def select_cursor( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> ContextManager[Any]: ... def insert_update_delete( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... def insert_update_delete_many( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... def insert_returning( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> Optional[Any]: ... def execute_script(self, conn: Any, sql: str) -> None: ... Async Adapter class AsyncDriverAdapterProtocol(Protocol): is_aio_driver = True def process_sql(self, query_name: str, op_type: SQLOperationType, sql: str) -> str: ... async def select( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> List: ... async def select_one( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> Optional[Any]: ... async def select_cursor( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> AsyncContextManager[Any]: ... async def insert_update_delete( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... async def insert_update_delete_many( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... async def insert_returning( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> Optional[Any]: ... async def execute_script(self, conn: Any, sql: str) -> None: ... There isn't much difference between these two protocols besides the async def syntax for the method definition. There is one more sneaky difference, the aiosql code expects async adapters to have a static class field is_aio_driver = True so it can tell when to use await for method returns. Looking at the source of the builtin adapters/ is a great place to start seeing how you may write your own database driver adapter. To use the adapter pass it's constructor or factory as the driver_adapter argument when building Queries. queries = aiosql.from_path(\"foo.sql\", driver_adapter=MyDbAdapter) Please ask questions on GitHub Issues . If the community makes additional adapter add-ons I'll be sure to list them here.","title":"Database Driver Adapters"},{"location":"database-driver-adapters/#database-driver-adapters","text":"Database driver adapters in aiosql allow extension of the library to support additional database drivers. If you are using a driver other than the ones currently supported by built-in driver adapters ( sqlite3 , aiosqlite , psycopg2 , asyncpg ) then you will need to make your own. A database driver adapter is a duck-typed class that follows either of the Protocol types below. These types are defined in aiosql/types.py . Sync Adapter class SyncDriverAdapterProtocol(Protocol): def process_sql(self, query_name: str, op_type: SQLOperationType, sql: str) -> str: ... def select( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> List: ... def select_one( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> Optional[Any]: ... def select_cursor( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> ContextManager[Any]: ... def insert_update_delete( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... def insert_update_delete_many( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... def insert_returning( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> Optional[Any]: ... def execute_script(self, conn: Any, sql: str) -> None: ... Async Adapter class AsyncDriverAdapterProtocol(Protocol): is_aio_driver = True def process_sql(self, query_name: str, op_type: SQLOperationType, sql: str) -> str: ... async def select( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> List: ... async def select_one( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict], record_class=Optional[Callable], ) -> Optional[Any]: ... async def select_cursor( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> AsyncContextManager[Any]: ... async def insert_update_delete( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... async def insert_update_delete_many( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> None: ... async def insert_returning( self, conn: Any, query_name: str, sql: str, parameters: Union[List, Dict] ) -> Optional[Any]: ... async def execute_script(self, conn: Any, sql: str) -> None: ... There isn't much difference between these two protocols besides the async def syntax for the method definition. There is one more sneaky difference, the aiosql code expects async adapters to have a static class field is_aio_driver = True so it can tell when to use await for method returns. Looking at the source of the builtin adapters/ is a great place to start seeing how you may write your own database driver adapter. To use the adapter pass it's constructor or factory as the driver_adapter argument when building Queries. queries = aiosql.from_path(\"foo.sql\", driver_adapter=MyDbAdapter) Please ask questions on GitHub Issues . If the community makes additional adapter add-ons I'll be sure to list them here.","title":"Database Driver Adapters"},{"location":"defining-sql-queries/","text":"Defining SQL Queries \u00b6 Query Names \u00b6 Name definitions are how aiosql determines the name of the methods that SQL code blocks are accessible by. A query name is defined by a SQL comment of the form \"-- name: \". -- name: get_all_blogs select * from blogs; This query will be available in aiosql under the python method name .get_all_blogs(conn) Query Comments \u00b6 ./sql/blogs.sql -- name: get_all_blogs -- Fetch all fields for every blog in the database. select * from blogs; Any other SQL comments you make between the name definition and your code will be used a the python documentation string for the generated method. You can use help() in the Python REPL to view these comments while using python. Python 3.8.3 (default, May 17 2020, 18:15:42) [GCC 10.1.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import aiosql >>> queries = aiosql.from_path(\"sql\", \"sqlite3\") >>> help(queries.get_all_blogs) Help on method get_all_blogs in module aiosql.queries: get_all_blogs(conn, *args, **kwargs) method of aiosql.queries.Queries instance Fetch all fields for every blog in the database. Operators \u00b6 This section describes the usage of various query operator symbols that you can annotate query names with in order to direct how aiosql will execute and return results. No Operator (Default) \u00b6 In the above Query Names section the get-all-blogs name is written without any trailing operators. -- name: get_all_blogs The lack of an operator is actually the most basic operator used by default for your queries. This tells aiosql to execute the query and to return all the results. In the case of get-all-blogs that means a select statement will be executed and a list of rows will be returned. When writing your application you will often need to perform other operations besides select , like insert , delete , and perhaps bulk operations. The operators detailed in the other sections of this doc let you declare in your SQL code how that query should be executed by a python database driver. ^ Select One \u00b6 The ^ operator executes a query and returns the first row of a result set. When there are no rows in the result set it returns None . This is useful when you know there should be one, and exactly one result from your query. As an example, if you have a unique constraint on the username field in your users table which makes it impossible for two users to share the same username, you could use ^ to direct aiosql to select a single user rather than a list of rows of length 1. -- name: get_user_by_username^ select userid, username, name from users where username = :username; When used from Python this query will either return None or the singular selected row. queries.get_user_by_username(conn, username=\"willvaughn\") # => (1, \"willvaughn\", \"William Vaughn\") or None ! Insert/Update/Delete \u00b6 The ! operator executes SQL without returning any results. It is meant for statements that use insert , update , and delete to make modifications to database rows without a necessary return value. -- name: publish_blog! insert into blogs(userid, title, content) values (:userid, :title, :content); -- name: remove_blog! -- Remove a blog from the database delete from blogs where blogid = :blogid; The methods generated are: publish_blog(conn, userid: int, title: str, content: str) -> None: remove_blog(conn, blogid: int) -> None: Each can be called to alter the database, but both will return None . <! Insert/Update/Delete Returning \u00b6 When performing a modification of rows, or adding new rows, sometimes it is necessary to return values using the returning clause where available. With the <! operator aiosql can execute a query and return values. When using SQLite this operator will return the id of the inserted row using cur.lastrowid . -- name: publish_blog<! insert into blogs(userid, title, content) values (:userid, :title, :content); Executing this query in python will return the blogid of the inserted row. queries = aiosql.from_path(\"blogs.sql\", \"sqlite3\") # ... connection code ... blogid = queries.publish_blog(conn, userid=1, title=\"Hi\" content=\"blah blah.\") PostgreSQL allows returning multiple values via the returning clause of queries. This same query using psycopg2 might look like the following. -- name: publish_blog<! insert into (userid, title, content) values (:userid, :title, :content) returning blogid, title; In python a tuple is returned with the blogid and title of the inserted row. queries = aiosql.from_path(\"blogs.sql\", \"psycopg2\") # ... connection code ... blogid, title = queries.publish_blog(conn, userid=1, title=\"Hi\" content=\"blah blah.\") *! Insert/Update/Delete Many \u00b6 The *! operator directs aiosql to execute a SQL statement over all items of a given sequence. Under the hood this calls the executemany method of many database drivers. See sqlite3 Cursor.executemany for an example. In aiosql we can use this for a bulk publish method that operates over a list of blog entries. -- name: bulk_publish*! -- Insert many blogs at once insert into blogs (userid, title, content, published) values (:userid, :title, :content, :published); queries = aiosql.from_path(\"blogs.sql\", \"psycopg2\") # ... connection code ... blogs = [ {\"userid\": 1, \"title\": \"First Blog\", \"content\": \"...\", published: datetime(2018, 1, 1)}, {\"userid\": 1, \"title\": \"Next Blog\", \"content\": \"...\", published: datetime(2018, 1, 2)}, {\"userid\": 2, \"title\": \"Hey, Hey!\", \"content\": \"...\", published: datetime(2018, 7, 28)}, ] queries.bulk_publish(conn, blogs) # Execute Scripts \u00b6 Using this operarator will execute sql statements as a script. You can't do variable substitution with the # operator. An example usecase is using data definition statements like create table in order to setup a database. -- name: create_schema# create table users ( userid integer not null primary key, username text not null, firstname integer not null, lastname text not null ); create table blogs ( blogid integer not null primary key, userid integer not null, title text not null, content text not null, published date not null default CURRENT_DATE, foreign key(userid) references users(userid) ); queries = aiosql.from_path(\"create_schema.sql\", \"sqlite3\") # ... connection code ... queries.create_schema(conn)","title":"Defining SQL Queries"},{"location":"defining-sql-queries/#defining-sql-queries","text":"","title":"Defining SQL Queries"},{"location":"defining-sql-queries/#query-names","text":"Name definitions are how aiosql determines the name of the methods that SQL code blocks are accessible by. A query name is defined by a SQL comment of the form \"-- name: \". -- name: get_all_blogs select * from blogs; This query will be available in aiosql under the python method name .get_all_blogs(conn)","title":"Query Names"},{"location":"defining-sql-queries/#query-comments","text":"./sql/blogs.sql -- name: get_all_blogs -- Fetch all fields for every blog in the database. select * from blogs; Any other SQL comments you make between the name definition and your code will be used a the python documentation string for the generated method. You can use help() in the Python REPL to view these comments while using python. Python 3.8.3 (default, May 17 2020, 18:15:42) [GCC 10.1.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import aiosql >>> queries = aiosql.from_path(\"sql\", \"sqlite3\") >>> help(queries.get_all_blogs) Help on method get_all_blogs in module aiosql.queries: get_all_blogs(conn, *args, **kwargs) method of aiosql.queries.Queries instance Fetch all fields for every blog in the database.","title":"Query Comments"},{"location":"defining-sql-queries/#operators","text":"This section describes the usage of various query operator symbols that you can annotate query names with in order to direct how aiosql will execute and return results.","title":"Operators"},{"location":"defining-sql-queries/#no-operator-default","text":"In the above Query Names section the get-all-blogs name is written without any trailing operators. -- name: get_all_blogs The lack of an operator is actually the most basic operator used by default for your queries. This tells aiosql to execute the query and to return all the results. In the case of get-all-blogs that means a select statement will be executed and a list of rows will be returned. When writing your application you will often need to perform other operations besides select , like insert , delete , and perhaps bulk operations. The operators detailed in the other sections of this doc let you declare in your SQL code how that query should be executed by a python database driver.","title":"No Operator (Default)"},{"location":"defining-sql-queries/#select-one","text":"The ^ operator executes a query and returns the first row of a result set. When there are no rows in the result set it returns None . This is useful when you know there should be one, and exactly one result from your query. As an example, if you have a unique constraint on the username field in your users table which makes it impossible for two users to share the same username, you could use ^ to direct aiosql to select a single user rather than a list of rows of length 1. -- name: get_user_by_username^ select userid, username, name from users where username = :username; When used from Python this query will either return None or the singular selected row. queries.get_user_by_username(conn, username=\"willvaughn\") # => (1, \"willvaughn\", \"William Vaughn\") or None","title":"^ Select One"},{"location":"defining-sql-queries/#insertupdatedelete","text":"The ! operator executes SQL without returning any results. It is meant for statements that use insert , update , and delete to make modifications to database rows without a necessary return value. -- name: publish_blog! insert into blogs(userid, title, content) values (:userid, :title, :content); -- name: remove_blog! -- Remove a blog from the database delete from blogs where blogid = :blogid; The methods generated are: publish_blog(conn, userid: int, title: str, content: str) -> None: remove_blog(conn, blogid: int) -> None: Each can be called to alter the database, but both will return None .","title":"! Insert/Update/Delete"},{"location":"defining-sql-queries/#insertupdatedelete-returning","text":"When performing a modification of rows, or adding new rows, sometimes it is necessary to return values using the returning clause where available. With the <! operator aiosql can execute a query and return values. When using SQLite this operator will return the id of the inserted row using cur.lastrowid . -- name: publish_blog<! insert into blogs(userid, title, content) values (:userid, :title, :content); Executing this query in python will return the blogid of the inserted row. queries = aiosql.from_path(\"blogs.sql\", \"sqlite3\") # ... connection code ... blogid = queries.publish_blog(conn, userid=1, title=\"Hi\" content=\"blah blah.\") PostgreSQL allows returning multiple values via the returning clause of queries. This same query using psycopg2 might look like the following. -- name: publish_blog<! insert into (userid, title, content) values (:userid, :title, :content) returning blogid, title; In python a tuple is returned with the blogid and title of the inserted row. queries = aiosql.from_path(\"blogs.sql\", \"psycopg2\") # ... connection code ... blogid, title = queries.publish_blog(conn, userid=1, title=\"Hi\" content=\"blah blah.\")","title":"&lt;! Insert/Update/Delete Returning"},{"location":"defining-sql-queries/#insertupdatedelete-many","text":"The *! operator directs aiosql to execute a SQL statement over all items of a given sequence. Under the hood this calls the executemany method of many database drivers. See sqlite3 Cursor.executemany for an example. In aiosql we can use this for a bulk publish method that operates over a list of blog entries. -- name: bulk_publish*! -- Insert many blogs at once insert into blogs (userid, title, content, published) values (:userid, :title, :content, :published); queries = aiosql.from_path(\"blogs.sql\", \"psycopg2\") # ... connection code ... blogs = [ {\"userid\": 1, \"title\": \"First Blog\", \"content\": \"...\", published: datetime(2018, 1, 1)}, {\"userid\": 1, \"title\": \"Next Blog\", \"content\": \"...\", published: datetime(2018, 1, 2)}, {\"userid\": 2, \"title\": \"Hey, Hey!\", \"content\": \"...\", published: datetime(2018, 7, 28)}, ] queries.bulk_publish(conn, blogs)","title":"*! Insert/Update/Delete Many"},{"location":"defining-sql-queries/#execute-scripts","text":"Using this operarator will execute sql statements as a script. You can't do variable substitution with the # operator. An example usecase is using data definition statements like create table in order to setup a database. -- name: create_schema# create table users ( userid integer not null primary key, username text not null, firstname integer not null, lastname text not null ); create table blogs ( blogid integer not null primary key, userid integer not null, title text not null, content text not null, published date not null default CURRENT_DATE, foreign key(userid) references users(userid) ); queries = aiosql.from_path(\"create_schema.sql\", \"sqlite3\") # ... connection code ... queries.create_schema(conn)","title":"# Execute Scripts"},{"location":"getting-started/","text":"Getting Started \u00b6 Philosophy \u00b6 The aiosql project is for writing SQL to interact with a database. Most database libraries are intended to reduce the amount of SQL developers need to write, aiosql takes an alternative approach. Why? Alternatives are good. No approach fits all use cases, no matter how predominant. SQL is the most expressive and performant way to interact with a SQL database. Investigating where a query came from is simpler when it is source controlled, named, and written by a human. Writing SQL in files gives you built-in compatibility with powerful SQL tools like DataGrip and psql . About ORMs \u00b6 ORMs and SQL Query Builders offer object interfaces to generate and execute SQL. They exist to ease development, not to make it simpler. Inheriting object hierarchies, mixing data with behaviors, mirroring a database schema, and generating SQL are not simple. ORMs are introduced early in a project's life when requirements are limited and the need to move fast is paramount. As a project grows, ORM objects and their relations grow too, they become a source of complexity and coupling. aiosql doesn't solve these problems directly either, your application will still get more complex with time. You can write bad SQL and bad python. But, with aiosql there is no mandate that all interaction with the database go through a complex network of related python objects that mirror a database schema. The only mandates are that you write SQL to talk to the database and python to use the data. From there you start with a system in which the database and the application are intentionally separate and independent from each other so they can change independently. The architecture of your application and the boundaries you choose between it and the database is left to you. The documentation for projects like SQLAlchemy and Django DB can give you a better vision for the class of problems that ORMs do solve and the productivity gains they intend. Please choose these projects over aiosql if you find that they fit the needs of your application better. Loading Queries \u00b6 This section goes over the three ways to make SQL queries available for execution in python. You'll learn the basics of defining queries so aiosql can find them and turn them into methods on a Queries object. For more details reference the Defining SQL Queries documentation. From a SQL File \u00b6 SQL can be loaded by providing a path to a .sql file. Below is a blogs.sql file that defines two queries. -- name: get_all_blogs select blogid, userid, title, content, published from blogs; -- name: get_user_blogs -- Get blogs with a fancy formatted published date and author field select b.blogid, b.title, strftime('%Y-%m-%d %H:%M', b.published) as published, u.username as author from blogs b inner join users u on b.userid = u.userid where u.username = :username order by b.published desc; Notice the --name: <name_of_method> comments and the :username substitution variable. The comments that start with --name: are the magic of aiosql. They are used by aiosql.from_path to parse the file into separate methods accessible by the name. The aiosql.from_path function takes a path to a sql file or directory and the name of the database driver intended for use with the methods. queries = aiosql.from_path(\"blogs.sql\", \"sqlite3\") In the case of blogs.sql we expect the following two methods to be available. The username parameter of get_user_blogs will substitute in for the :username variable in the SQL. def get_all_blogs(self) -> List: pass def get_user_blogs(self, username: str) -> List: pass From a SQL String \u00b6 SQL can be loaded from a string as well. The result below is the same as the first example above that loads from a SQL file. sql_str = \"\"\" -- name: get_all_blogs select blogid, userid, title, content, published from blogs; -- name: get_user_blogs -- Get blogs with a fancy formatted published date and author field select b.blogid, b.title, strftime('%Y-%m-%d %H:%M', b.published) as published, u.username as author from blogs b inner join users u on b.userid = u.userid where u.username = :username order by b.published desc; \"\"\" queries = aiosql.from_str(sql_str, \"sqlite3\") The Queries object here will have two methods: queries.get_all_blogs(conn) queries.get_user_blogs(conn, username=\"johndoe\") From a Directory of SQL Files \u00b6 Loading a directory of SQL files loads all of the queries defined in those files into a single object. The example/sql directory below contains three .sql files and can be loaded using aiosql.from_path . example/sql \u251c\u2500\u2500 blogs.sql \u251c\u2500\u2500 create_schema.sql \u2514\u2500\u2500 users.sql queries = aiosql.from_path(\"example/sql\", \"sqlite3\") The resulting queries object will have a mixture of methods from all the files. Warning Don't name queries the same in various files in the same directory. The last one loaded will win. See Subdirectories below to namespace queries. Subdirectories \u00b6 Introducing subdirectories allows namspacing queries. This provides a way to further organize and group queries conceptually. For instance, you could define blog queries separate from user queries access them on distinct properties of the queries object. Assume the blogs.sql and users.sql files both contain a --name: get_all query. example/sql \u251c\u2500\u2500 blogs \u2502 \u2514\u2500\u2500 blogs.sql \u251c\u2500\u2500 create_schema.sql \u2514\u2500\u2500 users \u2514\u2500\u2500 users.sql queries = aiosql.from_path(\"example/sql\", \"sqlite3\") The Queries object has two nested get_all methods accessible on attributes .blogs and .users . The attributes reflect the names of the subdirectories. queries.blogs.get_all(conn) queries.users.get_all(conn) Calling Query Methods \u00b6 Connections \u00b6 The connection or conn is always the first argument to an aiosql method. The conn is an open connection to a database driver that your aiosql method can use for executing the sql it contains. Controlling connections outside of aiosql queries means you can call multiple queries and control them under one transaction, or otherwise set connection level properties that affect driver behavior. Note For more see: Leveraging Driver Specific Features . In the examples throughout this page a conn object has been passed. Here is a more code complete example that shows the connection creation and call to aiosql.from_path that make a queries object. >>> import sqlite3 >>> import aiosql >>> conn = sqlite3.connect(\"./mydb.sql\") >>> # Note the \"sqlite3\" driver_adapter argument is what tells >>> # aiosql it should be expecting a sqlite3 connection object. >>> queries = aiosql.from_path(\"./blogs.sql\", \"sqlite3\") >>> queries.get_all_blogs(conn) [(1, 1, 'What I did Today', 'I mowed the lawn, washed some clothes, and ate a burger.\\n' '\\n' 'Until next time,\\n' 'Bob', '2017-07-28'), (2, 3, 'Testing', 'Is this thing on?\\n', '2018-01-01'), (3, 1, 'How to make a pie.', '1. Make crust\\n2. Fill\\n3. Bake\\n4. Eat\\n', '2018-11-23')] Passing Parameters \u00b6 -- name: get_user_blogs -- Get blogs with a fancy formatted published date and author field select b.blogid, b.title, strftime('%Y-%m-%d %H:%M', b.published) as published, u.username as author from blogs b inner join users u on b.userid = u.userid where u.username = :username order by b.published desc; aiosql allows paremeterization of queries by parsing values like :username in the above query and having the resultant method expect an inbound argument to substitute for :username . You can call the get_user_blogs function with plain arguments or keyword arguments with the name of the subsitution variable. >>> import sqlite3 >>> import aiosql >>> conn = sqlite3.connect(\"./mydb.sql\") >>> queries = aiosql.from_path(\"./blogs.sql\", \"sqlite3\") >>> >>> # Using keyword args >>> queries.get_user_blogs(conn, username=\"bobsmith\") [(3, 'How to make a pie.', '2018-11-23 00:00', 'bobsmith'), (1, 'What I did Today', '2017-07-28 00:00', 'bobsmith')] >>> >>> # Using positional argument >>> queries.get_user_blogs(conn, \"janedoe\") [(2, 'Testing', '2018-01-01 00:00', 'janedoe')] Warning When passing positional arguments aiosql will apply them in the order that the substitutions appear in your SQL. This can be convenient and clear in some cases, but confusing in others. You might want to choose to always name your arguments for clarity.","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#philosophy","text":"The aiosql project is for writing SQL to interact with a database. Most database libraries are intended to reduce the amount of SQL developers need to write, aiosql takes an alternative approach. Why? Alternatives are good. No approach fits all use cases, no matter how predominant. SQL is the most expressive and performant way to interact with a SQL database. Investigating where a query came from is simpler when it is source controlled, named, and written by a human. Writing SQL in files gives you built-in compatibility with powerful SQL tools like DataGrip and psql .","title":"Philosophy"},{"location":"getting-started/#about-orms","text":"ORMs and SQL Query Builders offer object interfaces to generate and execute SQL. They exist to ease development, not to make it simpler. Inheriting object hierarchies, mixing data with behaviors, mirroring a database schema, and generating SQL are not simple. ORMs are introduced early in a project's life when requirements are limited and the need to move fast is paramount. As a project grows, ORM objects and their relations grow too, they become a source of complexity and coupling. aiosql doesn't solve these problems directly either, your application will still get more complex with time. You can write bad SQL and bad python. But, with aiosql there is no mandate that all interaction with the database go through a complex network of related python objects that mirror a database schema. The only mandates are that you write SQL to talk to the database and python to use the data. From there you start with a system in which the database and the application are intentionally separate and independent from each other so they can change independently. The architecture of your application and the boundaries you choose between it and the database is left to you. The documentation for projects like SQLAlchemy and Django DB can give you a better vision for the class of problems that ORMs do solve and the productivity gains they intend. Please choose these projects over aiosql if you find that they fit the needs of your application better.","title":"About ORMs"},{"location":"getting-started/#loading-queries","text":"This section goes over the three ways to make SQL queries available for execution in python. You'll learn the basics of defining queries so aiosql can find them and turn them into methods on a Queries object. For more details reference the Defining SQL Queries documentation.","title":"Loading Queries"},{"location":"getting-started/#from-a-sql-file","text":"SQL can be loaded by providing a path to a .sql file. Below is a blogs.sql file that defines two queries. -- name: get_all_blogs select blogid, userid, title, content, published from blogs; -- name: get_user_blogs -- Get blogs with a fancy formatted published date and author field select b.blogid, b.title, strftime('%Y-%m-%d %H:%M', b.published) as published, u.username as author from blogs b inner join users u on b.userid = u.userid where u.username = :username order by b.published desc; Notice the --name: <name_of_method> comments and the :username substitution variable. The comments that start with --name: are the magic of aiosql. They are used by aiosql.from_path to parse the file into separate methods accessible by the name. The aiosql.from_path function takes a path to a sql file or directory and the name of the database driver intended for use with the methods. queries = aiosql.from_path(\"blogs.sql\", \"sqlite3\") In the case of blogs.sql we expect the following two methods to be available. The username parameter of get_user_blogs will substitute in for the :username variable in the SQL. def get_all_blogs(self) -> List: pass def get_user_blogs(self, username: str) -> List: pass","title":"From a SQL File"},{"location":"getting-started/#from-a-sql-string","text":"SQL can be loaded from a string as well. The result below is the same as the first example above that loads from a SQL file. sql_str = \"\"\" -- name: get_all_blogs select blogid, userid, title, content, published from blogs; -- name: get_user_blogs -- Get blogs with a fancy formatted published date and author field select b.blogid, b.title, strftime('%Y-%m-%d %H:%M', b.published) as published, u.username as author from blogs b inner join users u on b.userid = u.userid where u.username = :username order by b.published desc; \"\"\" queries = aiosql.from_str(sql_str, \"sqlite3\") The Queries object here will have two methods: queries.get_all_blogs(conn) queries.get_user_blogs(conn, username=\"johndoe\")","title":"From a SQL String"},{"location":"getting-started/#from-a-directory-of-sql-files","text":"Loading a directory of SQL files loads all of the queries defined in those files into a single object. The example/sql directory below contains three .sql files and can be loaded using aiosql.from_path . example/sql \u251c\u2500\u2500 blogs.sql \u251c\u2500\u2500 create_schema.sql \u2514\u2500\u2500 users.sql queries = aiosql.from_path(\"example/sql\", \"sqlite3\") The resulting queries object will have a mixture of methods from all the files. Warning Don't name queries the same in various files in the same directory. The last one loaded will win. See Subdirectories below to namespace queries.","title":"From a Directory of SQL Files"},{"location":"getting-started/#subdirectories","text":"Introducing subdirectories allows namspacing queries. This provides a way to further organize and group queries conceptually. For instance, you could define blog queries separate from user queries access them on distinct properties of the queries object. Assume the blogs.sql and users.sql files both contain a --name: get_all query. example/sql \u251c\u2500\u2500 blogs \u2502 \u2514\u2500\u2500 blogs.sql \u251c\u2500\u2500 create_schema.sql \u2514\u2500\u2500 users \u2514\u2500\u2500 users.sql queries = aiosql.from_path(\"example/sql\", \"sqlite3\") The Queries object has two nested get_all methods accessible on attributes .blogs and .users . The attributes reflect the names of the subdirectories. queries.blogs.get_all(conn) queries.users.get_all(conn)","title":"Subdirectories"},{"location":"getting-started/#calling-query-methods","text":"","title":"Calling Query Methods"},{"location":"getting-started/#connections","text":"The connection or conn is always the first argument to an aiosql method. The conn is an open connection to a database driver that your aiosql method can use for executing the sql it contains. Controlling connections outside of aiosql queries means you can call multiple queries and control them under one transaction, or otherwise set connection level properties that affect driver behavior. Note For more see: Leveraging Driver Specific Features . In the examples throughout this page a conn object has been passed. Here is a more code complete example that shows the connection creation and call to aiosql.from_path that make a queries object. >>> import sqlite3 >>> import aiosql >>> conn = sqlite3.connect(\"./mydb.sql\") >>> # Note the \"sqlite3\" driver_adapter argument is what tells >>> # aiosql it should be expecting a sqlite3 connection object. >>> queries = aiosql.from_path(\"./blogs.sql\", \"sqlite3\") >>> queries.get_all_blogs(conn) [(1, 1, 'What I did Today', 'I mowed the lawn, washed some clothes, and ate a burger.\\n' '\\n' 'Until next time,\\n' 'Bob', '2017-07-28'), (2, 3, 'Testing', 'Is this thing on?\\n', '2018-01-01'), (3, 1, 'How to make a pie.', '1. Make crust\\n2. Fill\\n3. Bake\\n4. Eat\\n', '2018-11-23')]","title":"Connections"},{"location":"getting-started/#passing-parameters","text":"-- name: get_user_blogs -- Get blogs with a fancy formatted published date and author field select b.blogid, b.title, strftime('%Y-%m-%d %H:%M', b.published) as published, u.username as author from blogs b inner join users u on b.userid = u.userid where u.username = :username order by b.published desc; aiosql allows paremeterization of queries by parsing values like :username in the above query and having the resultant method expect an inbound argument to substitute for :username . You can call the get_user_blogs function with plain arguments or keyword arguments with the name of the subsitution variable. >>> import sqlite3 >>> import aiosql >>> conn = sqlite3.connect(\"./mydb.sql\") >>> queries = aiosql.from_path(\"./blogs.sql\", \"sqlite3\") >>> >>> # Using keyword args >>> queries.get_user_blogs(conn, username=\"bobsmith\") [(3, 'How to make a pie.', '2018-11-23 00:00', 'bobsmith'), (1, 'What I did Today', '2017-07-28 00:00', 'bobsmith')] >>> >>> # Using positional argument >>> queries.get_user_blogs(conn, \"janedoe\") [(2, 'Testing', '2018-01-01 00:00', 'janedoe')] Warning When passing positional arguments aiosql will apply them in the order that the substitutions appear in your SQL. This can be convenient and clear in some cases, but confusing in others. You might want to choose to always name your arguments for clarity.","title":"Passing Parameters"}]}